## 📌 주제별 학습 정리 (개인 작성)

---

### 📍 Topic B – JPA 개념

---

### 1️⃣ 핵심 개념 한 줄
> ORM은 객체 지향 언어의 객체와 관계형 DB의 테이블을 매핑해서, SQL을 직접 쓰지 않고도 DB를 다룰 수 있게 해주는 기술이다.
> JPA는 자바 객체와 관계형 데이터베이스를 매핑하기 위한 ORM 표준 인터페이스이다.


---

### 2️⃣ 동작 원리 요약

- **왜 필요한가?**
  - SQL이 아닌 객체 중심으로 데이터를 처리 함으로써 객체를 중심으로 개발할 수 있다.
  - 테이블 구조 변경 시 SQL 수정 등이 최소화되니 유지보수와 확장성 면에서 좋다.
- **어떻게 동작하는가?**
  - https://miiiiiin-devlog.tistory.com/134
  - JPA에서는 persist()를 호출하면 바로 INSERT SQL이 실행되지 않고, 엔티티가 영속성 컨텍스트에 저장된다. 이후 트랜잭션 커밋 시점에 flush가 발생하면서 쓰기 지연 상태였던 INSERT SQL이 실행되고 DB에 반영되게 된다.
  - 영속성 컨텍스트에서 find로 엔티티를 조회하면, 해당 객체는 영속 상태의 엔티티가 된다. 이때 조회된 엔티티는 영속성 컨텍스트의 1차 캐시에 저장되며, 동시에 조회 시점의 상태를 기준으로 최초 스냅샷이 내부적으로 함께 저장된다.이후 애플리케이션에서 영속 엔티티의 값을 변경하더라도, 그 즉시 데이터베이스에 반영되지는 않고, 단순히 객체의 필드 값만 변경된 상태로 유지된다. 트랜잭션이 종료되면서 commit이 호출되면, 영속성 컨텍스트는 현재 엔티티의 상태와 최초 스냅샷을 비교한다. 이 과정에서 변경 사항이 감지되면(Dirty Checking), 해당 변경 내용을 반영하는 UPDATE SQL을 생성하여 쓰기 지연 SQL 저장소에 등록한다.

---

### 3️⃣ 핵심 키워드

- `영속성 컨텍스트`
- `commit & flush`
- `Dirty Checking`

---

### 4️⃣ 주의 포인트

- ❗ 영속 객체 = DB에 저장된 객체 (X) => 영속성 컨텍스트에 의해 관리되는 객체
- persist하면 바로 INSERT 된다 (X) => flush 시점에 실행
- ⚠️ JPA = Hibernate (X) => JPA는 표준, Hibernate는 구현체

### 5️⃣ 자주 나오는 면접 질문 (선택)

- Q. ORM이 무엇이고, 왜 사용하나요?
    - ORM은 객체 지향 언어의 객체와 관계형 DB의 테이블을 매핑해주는 기술입니다. 코드 레벨에서의 복잡한 SQL 작성을 최소화하고, 비즈니스 로직에 집중 가능하며 객체 중심 개발에 효율적이라는 장점이 있어서 사용합니다.

- Q.JPA와 Hibernate의 관계를 설명해주세요.
    - JPA는 자바 진영의 표준 ORM 인터페이스이고, Hibernate는 jPA를 구현한 구현체입니다. JPA는 규약이고 Hibernate는 실제 동작을 담당합니다.
    

- Q.Entity와 Table의 차이는 무엇인가요?
    - Table: 관계형 데이터베이스의 물리적인 데이터 저장 구조입니다. 행(Row)과 열(Column)로 구성되며, SQL로 조작합니다.
    - Entity: 객체 지향 프로그래밍의 클래스로, 비즈니스 로직과 데이터를 함께 가진 객체입니다. JPA가 이를 테이블과 매핑해줍니다.

```
핵심 차이:

Entity는 객체, Table은 데이터 저장소
Entity는 메서드와 로직을 가질 수 있지만, Table은 순수 데이터만 저장
Entity는 연관관계를 객체 참조로 표현하지만, Table은 외래키로 표현
Entity는 상속 관계를 가질 수 있지만, Table은 상속 개념이 없음
```
    

- Q.영속성 컨텍스트와 영속 객체가 무엇인가요?
    - JPA가 관리하는 "엔티티들을 영구 저장하는 환경"이라는 논리적 개념입니다. 이는 애플리케이션과 데이터베이스 사이에서 객체를 관리하는 가상의 논리공간(데이터베이스) 역할을 합니다.
    

### 6️⃣ 꼬리 질문 & 대응 포인트 (선택)

- 꼬리 질문: ORM의 단점은 무엇인가요?
- 대응 논리: 복잡한 쿼리나 대용량 데이터 처리 시 ORM이 생성한 SQL이 비효율적일 수 있습니다. 또한, 적절치 않은 상황에서 사용 시 N+1 문제, 불필요한 쿼리 등이 발생할 수 있습니다. 특정 최적화나 복잡한 쿼리는 직접 SQL을 작성하는 것이 나을 수 있습니다.

- 꼬리 질문: Entity와 DTO의 차이는 무엇인가요?
- 대응 논리: Entity는 JPA가 관리하는 영속성 컨텍스트 내의 객체이고, 비즈니스 로직을 포함 가능하며 생명주기를 JPA가 관리합니다. DTO는 계층 간 데이터 전달용 순수 자바 객체입니다.


- 꼬리 질문: 영속 객체의 값을 변경하면 바로 DB에 반영되나요?
- 대응 논리: 아닙니다. 영속 객체의 값을 변경하면 그 객체의 필드값만 바뀔 뿐입니다. 정확한 변경 시점은 트랜잭션 종료 시점에 변경 감지가 일어나고,flush 시점에 SQL이 실행됩니다.

- 꼬리 질문: 변경 감지(Dirty Checking)는 어떻게 동작하나요?
- 대응 논리: Dirty Checking의 동작은 엔티티가 영속 상태일 때 필드 값만 변경하면, 트랜잭션 종료 시점에 영속성 컨텍스트가 스냅샷과 비교하여 변경을 감지하고 자동으로 UPDATE SQL을 실행하는 것입니다.

```
JPA 변경감지 동작 원리

영속성 컨텍스트에서 find로 엔티티를 조회하면, 해당 객체는 영속 상태의 엔티티가 된다. 이때 조회된 엔티티는 영속성 컨텍스트의 1차 캐시에 저장되며, 동시에 조회 시점의 상태를 기준으로 최초 스냅샷이 내부적으로 함께 저장된다.
 
이후 애플리케이션에서 영속 엔티티의 값을 변경하더라도, 그 즉시 데이터베이스에 반영되지는 않고, 단순히 객체의 필드 값만 변경된 상태로 유지된다.
 
트랜잭션이 종료되면서 commit이 호출되면, 영속성 컨텍스트는 현재 엔티티의 상태와 최초 스냅샷을 비교한다. 이 과정에서 변경 사항이 감지되면(Dirty Checking), 해당 변경 내용을 반영하는 UPDATE SQL을 생성하여 쓰기 지연 SQL 저장소에 등록한다.
```

### 7️⃣ 실무 적용 or 가상 시나리오 (선택)

- 실제/가정 상황:
- 선택 이유:

