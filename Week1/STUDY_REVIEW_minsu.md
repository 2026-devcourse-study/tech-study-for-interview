## 📌 주제별 학습 정리

---

### 📍 Topic A - Spring 기본 / DI

---

### 1️⃣ 핵심 개념 한 줄
> **Spring의 DI는 객체 생성과 의존성 주입을 컨테이너가 담당하게 하여, 객체 간 결합도를 낮추고 유연한 변경과 테스트를 가능하게 하는 구조입니다.**

---

### 2️⃣ 동작 원리 요약

- **왜 필요한가?**
  - 객체가 구현체를 직접 생성(new)하면 변경에 취약
  - 구현 변경 시 해당 객체의 코드 수정이 필요 → OCP, DIP 위반
  - 실제 구현체에 의존하게 되어 단위 테스트가 어려움
  - 👉 DI는 의존성 결정을 코드(컴파일 타임)에서 분리하여 런타임으로 위임

- **어떻게 동작하는가?**
  - Spring은 IoC 컨테이너가 객체 생성과 생명주기를 관리
  - 개발자는 객체 간 의존 관계만 선언 (@Component, @Bean, @Autowired)
  - 컨테이너가 의존성을 주입하여 Bean을 제공
  - 기본적으로 Bean은 Singleton 스코프로 관리됨
  - 👉 객체 생성과 제어의 주체가 개발자에서 프레임워크로 이동 = IoC

**[기존 vs Spring 방식 비교]**
```
기존: 객체 생성 → 의존성 객체 생성(new) → 메소드 호출
Spring: 객체 생성 → 의존성 객체 주입(컨테이너) → 메소드 호출
```

---

### 3️⃣ 핵심 키워드

- **`IoC (Inversion of Control)`** - 객체 생성과 생명주기의 제어권을 **컨테이너**가 가짐
- **`DI (Dependency Injection)`** - IoC를 구현하는 방식, 주로 **생성자 주입** 사용
- **`Bean / ApplicationContext`** - Spring 컨테이너가 관리하는 객체 / Bean 관리 주체
- **`@ComponentScan + @Component`** - 자동 빈 등록: 지정 패키지부터 @Component 붙은 클래스 스캔
- **`@Autowired`** - 의존관계 자동 주입 (같은 타입의 Bean 조회)
- **`@Configuration + @Bean`** - 수동 빈 등록 + CGLIB를 통한 싱글톤 보장
- **`Constructor Injection`** - **불변성 보장, 테스트 용이, 순환 참조 방지** (필드/Setter 주입보다 권장)
- **`Singleton Scope (기본 전략)`** - 하나의 인스턴스를 재사용, **무상태(stateless) 설계 필수**

---

### 4️⃣ 주의 포인트

- ❗ **DI의 3가지 조건**
  1. 클래스는 **인터페이스에만 의존** (구체 클래스 의존 X)
  2. 런타임 의존관계는 **컨테이너/팩토리가 결정**
  3. 의존관계는 **외부에서 레퍼런스를 주입**받아 생성

- ⚠️ **싱글톤 Bean 사용 시 반드시 무상태(stateless) 설계**
  - 특정 클라이언트에 의존적인 필드 금지
  - 값을 변경할 수 있는 공유 필드 금지
  - 가급적 읽기만 가능하게 설계
  - 지역변수, 파라미터, ThreadLocal 사용

- ⚠️ **다형성만으로는 OCP/DIP를 지킬 수 없음**
  - 예: `MemberService service = new MemberServiceImpl();` → 구현체에 직접 의존 (DIP 위반)
  - 구현체 변경 시 클라이언트 코드 수정 필요 (OCP 위반)
  - **DI 컨테이너가 이 문제를 해결**

- ⚠️ **@Component vs @Bean**
  - `@Component`: 클래스 레벨, 컴포넌트 스캔으로 **자동 등록**
  - `@Bean`: 메서드 레벨, @Configuration 내에서 **수동 등록**

### 5️⃣ 자주 나오는 면접 질문 (선택)

- Q. **DI가 뭔가요?**
  - A. 객체를 직접 생성하지 않고 **외부(IoC 컨테이너)에서 생성 후 주입**하는 방식입니다. 이를 통해 **결합도를 낮추고** 변경과 테스트에 유연해집니다.

- Q. **IoC가 뭔가요?**
  - A. **제어의 역전**으로, 객체의 생명주기와 흐름 제어를 개발자가 아닌 **프레임워크(컨테이너)에 위임**하는 것입니다.

- Q. **Bean이 뭔가요?**
  - A. **Spring IoC 컨테이너가 관리하는 자바 객체**입니다. 기본적으로 싱글톤 스코프로 생성되며 `ApplicationContext.getBean()`으로 얻을 수 있습니다.

- Q. **빈 등록 방식은?**
  - A. 1) `@ComponentScan + @Component`로 **자동 등록**, 2) `@Configuration + @Bean`으로 **수동 등록**

- Q. **DI 안 쓰면 뭐가 문제인가요?**
  - A. 구현체를 직접 생성하면 **구체 클래스에 의존** → DIP 위반, 구현 변경 시 **클라이언트 코드 수정** 필요 → OCP 위반, **테스트 시 Mock 주입 불가능** → 단위 테스트 어려움

- Q. **생성자 주입을 권장하는 이유는?**
  - A. **불변성 보장**(final 사용 가능), **필수 의존성 명시**(누락 방지), **순환 참조 방지**(컴파일 타임에 감지), **테스트 용이**(순수 자바로 테스트 가능)

### 6️⃣ 꼬리 질문 & 대응 포인트 (선택)

- **꼬리 질문**: "인터페이스 없이 DI 가능한가요?"
  - **대응 논리**: 기술적으로 가능하지만 **DI의 핵심 가치 상실**. DI는 **추상화(인터페이스)에 의존**해야 구현체 교체가 자유로움. 구체 클래스에 의존하면 **DIP 위반 + 다형성 활용 불가**

- **꼬리 질문**: "Spring이 IoC 컨테이너인 이유는?"
  - **대응 논리**: 일반적으로 개발자가 `new`로 객체 생성 → 개발자가 제어. Spring은 **컨테이너가 객체를 생성·관리** → 제어권 역전. `ApplicationContext`가 Bean의 생명주기 전체를 담당

- **꼬리 질문**: "@Configuration이 없으면 어떻게 되나요?"
  - **대응 논리**: `@Bean` 메서드가 여러 번 호출되면 **매번 새 인스턴스 생성**. `@Configuration`이 있으면 **CGLIB 프록시**가 싱글톤 보장. 메서드 호출 시 이미 생성된 Bean이 있으면 재사용

- **꼬리 질문**: "같은 타입의 Bean이 여러 개면?"
  - **대응 논리**: `@Primary` - 우선순위 부여, `@Qualifier("빈이름")` - 명시적 지정, 필드명을 Bean 이름과 일치시키기

### 7️⃣ 실무 적용 or 가상 시나리오 (선택)

- **실제/가정 상황**:
- **선택 이유**: